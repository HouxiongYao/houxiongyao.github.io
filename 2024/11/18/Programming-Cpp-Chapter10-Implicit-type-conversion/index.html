<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/output32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/output16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic|Times New Roman:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-material.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="The process of producing a new value of some type from a value of a different type is called a conversion. Conversions do not change the value or type being converted. Instead, a new value with the de">
<meta property="og:type" content="article">
<meta property="og:title" content="Chapter10-Implicit-type-conversion">
<meta property="og:url" content="http://example.com/2024/11/18/Programming-Cpp-Chapter10-Implicit-type-conversion/index.html">
<meta property="og:site_name" content="熊熊学习乐园">
<meta property="og:description" content="The process of producing a new value of some type from a value of a different type is called a conversion. Conversions do not change the value or type being converted. Instead, a new value with the de">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-11-17T16:00:00.000Z">
<meta property="article:modified_time" content="2024-11-19T06:53:09.217Z">
<meta property="article:author" content="Houxiong">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2024/11/18/Programming-Cpp-Chapter10-Implicit-type-conversion/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Chapter10-Implicit-type-conversion | 熊熊学习乐园</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">熊熊学习乐园</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">A place for growing</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/HouxiongYao" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/11/18/Programming-Cpp-Chapter10-Implicit-type-conversion/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Houxiong">
      <meta itemprop="description" content="To learn, To copy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="熊熊学习乐园">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Chapter10-Implicit-type-conversion
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-11-18 00:00:00" itemprop="dateCreated datePublished" datetime="2024-11-18T00:00:00+08:00">2024-11-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-11-19 14:53:09" itemprop="dateModified" datetime="2024-11-19T14:53:09+08:00">2024-11-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Programming/" itemprop="url" rel="index"><span itemprop="name">Programming</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Programming/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>The process of producing a new value of some type from a value of a different type is called a <strong>conversion</strong>.</p>
<p>Conversions do not change the value or type being converted. Instead, a new value with the desired type is created as a result of the conversion <span id="more"></span></p>
<h1 id="implicit-type-conversion">Implicit type conversion</h1>
<p>If a valid conversion can be found, then the compiler will produce a new value of the desired type.</p>
<p>If the compiler can’t find an acceptable conversion, then the compilation will fail with a compile error</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x { <span class="number">3.5</span> }; <span class="comment">// brace-initialization disallows conversions that result in data loss</span></span><br></pre></td></tr></table></figure>
<h2 id="the-standard-conversions">The standard conversions</h2>
<ul>
<li>Numeric promotions</li>
<li>Numeric conversions</li>
<li>Arithmetic conversions</li>
<li>Other conversions # Floating-point and integral promotion</li>
</ul>
<h2 id="numeric-promotion">Numeric promotion</h2>
<p>A <strong>numeric promotion</strong> is the type conversion of certain narrower numeric types (such as a char) to certain wider numeric types (typically int or double) that can be processed efficiently.</p>
<p>All numeric promotions are value-preserving</p>
<p>The numeric promotion rules are divided into two subcategories: integral promotions and floating point promotions ### integral promotions</p>
<p>Using the integral promotion rules, the following conversions can be made:</p>
<ul>
<li>signed char or signed short can be converted to int.</li>
<li>unsigned char, char8_t, and unsigned short can be converted to int if int can hold the entire range of the type, or unsigned int otherwise.</li>
<li>If char is signed by default, it follows the signed char conversion rules above. If it is unsigned by default, it follows the unsigned char conversion rules above.</li>
<li>bool can be converted to int, with false becoming 0 and true becoming 1.</li>
</ul>
<p>While integral promotion is value-preserving, ==it does not necessarily preserve the signedness (signed/unsigned) of the type==. ### floating point promotions</p>
<p>Using the floating point promotion rules, a value of type float can be converted to a value of type double.</p>
<h1 id="numeric-conversions">Numeric conversions</h1>
<ul>
<li>Converting an integral type to any other integral type (excluding integral promotions):</li>
<li>Converting a floating point type to any other floating point type (excluding floating point promotions)</li>
<li>Converting a floating point type to any integral type</li>
<li>Converting an integral type to any floating point type</li>
<li>Converting an integral type or a floating point type to a bool</li>
</ul>
<h2 id="safe-and-unsafe-conversions">Safe and unsafe conversions</h2>
<p>Value-preserving conversions are safe numeric conversions where the destination type can exactly represent all possible values in the source type.</p>
<p>Reinterpretive conversions are unsafe numeric conversions where the converted value may be different than the source value, but no data is lost. Signed/unsigned conversions fall into this category.</p>
<p>Lossy conversions are unsafe numeric conversions where data may be lost during the conversion.</p>
<h1 id="narrowing-conversions-list-initialization-and-constexpr-initializers">Narrowing conversions, list initialization, and constexpr initializers</h1>
<h2 id="narrowing-coversions">Narrowing coversions</h2>
<p>In C++, a narrowing conversion is a potentially unsafe numeric conversion where the destination type may not be able to hold all the values of the source type.</p>
<p>The following conversions are defined to be narrowing:</p>
<ul>
<li>From a floating point type to an integral type.</li>
<li>From a floating point type to a narrower or lesser ranked floating point type, unless the value being converted is constexpr and is in range of the destination type (even if the destination type doesn’t have the precision to store all the significant digits of the number).</li>
<li>From an integral to a floating point type, unless the value being converted is constexpr and whose value can be stored exactly in the destination type.</li>
<li>From an integral type to another integral type that cannot represent all values of the original type, unless the value being converted is constexpr and whose value can be stored exactly in the destination type. This covers both wider to narrower integral conversions, as well as integral sign conversions (signed to unsigned, or vice-versa).</li>
</ul>
<h2 id="make-intentional-narrowing-conversions-explicit">Make intentional narrowing conversions explicit</h2>
<p>Use <code>static_cast</code> when narrowing conversions is needed.Doing so helps document that the narrowing conversion is intentional, and will suppress any compiler warnings or errors that would otherwise result.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">someFcn</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">double</span> d{ <span class="number">5.0</span> };</span><br><span class="line"></span><br><span class="line">    <span class="built_in">someFcn</span>(d); <span class="comment">// bad: implicit narrowing conversion will generate compiler warning</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// good: we're explicitly telling the compiler this narrowing conversion is intentional</span></span><br><span class="line">    <span class="built_in">someFcn</span>(<span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(d)); <span class="comment">// no warning generated</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="brace-initialization-disallows-narrowing-conversions">Brace initialization disallows narrowing conversions</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> i { <span class="number">3.5</span> }; <span class="comment">// won't compile</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="some-constexpr-conversions-arent-considered-narrowing">Some constexpr conversions aren’t considered narrowing</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> u)</span> <span class="comment">// note: unsigned</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    std::cout &lt;&lt; u &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Enter an integral value: "</span>;</span><br><span class="line">    <span class="type">int</span> n{};</span><br><span class="line">    std::cin &gt;&gt; n; <span class="comment">// enter 5 or -5</span></span><br><span class="line">    <span class="built_in">print</span>(n);      <span class="comment">// conversion to unsigned may or may not preserve value</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>compilier raises conversion to ‘unsigned int’ from ‘int’ may change the sign of the result .</p>
<p>When the source value of a narrowing conversion is constexpr, the specific value to be converted must be known to the compiler. In such cases, the compiler can perform the conversion itself, and then check whether the value was preserved. If the value was not preserved, the compiler can halt compilation with an error. If the value is preserved, the conversion is not considered to be narrowing (and the compiler can replace the entire conversion with the converted result, knowing that doing so is safe).</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> n1{ <span class="number">5</span> };   <span class="comment">// note: constexpr</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> u1 { n1 };  <span class="comment">// okay: conversion is not narrowing due to exclusion clause</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> n2 { <span class="number">-5</span> }; <span class="comment">// note: constexpr</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> u2 { n2 };  <span class="comment">// compile error: conversion is narrowing due to value change</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h1 id="arithmetic-conversions">Arithmetic conversions</h1>
<h1 id="typedefs-and-type-aliases">Typedefs and type aliases</h1>
<p>In C++, <strong>using</strong> is a keyword that creates an alias for an existing data type</p>
<p>example: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">using</span> Distance = <span class="type">double</span>; <span class="comment">// define Distance as an alias for type double</span></span><br><span class="line"></span><br><span class="line">    Distance milesToDestination{ <span class="number">3.4</span> }; <span class="comment">// defines a variable of type double</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; milesToDestination &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// prints a double value</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p>
<h2 id="naming-type-aliases">Naming type aliases</h2>
<ul>
<li>Type aliases that end in a “_t” suffix (the “_t” is short for “type”). This convention is often used by the standard library for globally scoped type names (like size_t and nullptr_t).</li>
<li>Type aliases that end in a “_type” suffix. This convention is used by some standard library types (like std::string) to name nested type aliases (e.g. std::string::size_type).</li>
<li>Type aliases that use no suffix.</li>
</ul>
<p>In modern C++, the convention is to name type aliases (or any other type) that you define yourself starting with a capital letter, and using no suffix.</p>
<h2 id="type-aliases-are-not-distinct-types">Type aliases are not distinct types</h2>
<p>An alias does not actually define a new, distinct type (one that is considered separate from other types) -- it just introduces a new identifier for an existing type.</p>
<h2 id="the-scope-of-a-type-alias">The scope of a type alias</h2>
<p>Because scope is a property of an identifier, type alias identifiers follow the same scoping rules as variable identifiers: a type alias defined inside a block has block scope and is usable only within that block, whereas a type alias defined in the global namespace has global scope and is usable to the end of the file.</p>
<h2 id="typedefs">Typedefs</h2>
<p>Prefer type aliases over typedefs.</p>
<h2 id="when-should-we-use-type-aliases">When should we use type aliases</h2>
<h3 id="using-type-aliases-for-platform-independent-coding">Using type aliases for platform independent coding</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> INT_2_BYTES</span></span><br><span class="line"><span class="keyword">using</span> <span class="type">int8_t</span> = <span class="type">char</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="type">int16_t</span> = <span class="type">int</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="type">int32_t</span> = <span class="type">long</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="type">int8_t</span> = <span class="type">char</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="type">int16_t</span> = <span class="type">short</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="type">int32_t</span> = <span class="type">int</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h3 id="using-type-aliases-to-make-complex-types-easier-to-read">Using type aliases to make complex types easier to read</h3>
<h3 id="using-type-aliases-to-document-the-meaning-of-a-value">Using type aliases to document the meaning of a value</h3>
<h3 id="using-type-aliases-for-easier-code-maintenance">Using type aliases for easier code maintenance</h3>
<h1 id="type-deduction-for-objects-using-the-auto-keyword">Type deduction for objects using the auto keyword</h1>
<h2 id="type-deduction-for-initialized-variables">Type deduction for initialized variables</h2>
<p><strong>Type deduction</strong> (also sometimes called type inference) is a feature that allows the compiler to deduce the type of an object from the object’s initializer</p>
<p>example: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">auto</span> d { <span class="number">5.0</span> }; <span class="comment">// 5.0 is a double literal, so d will be deduced as a double</span></span><br><span class="line">    <span class="keyword">auto</span> i { <span class="number">1</span> + <span class="number">2</span> }; <span class="comment">// 1 + 2 evaluates to an int, so i will be deduced as an int</span></span><br><span class="line">    <span class="keyword">auto</span> x { i }; <span class="comment">// i is an int, so x will be deduced as an int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p>
<p>Because function calls are valid expressions, we can even use type deduction when our initializer is a non-void function call: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">auto</span> sum { <span class="built_in">add</span>(<span class="number">5</span>, <span class="number">6</span>) }; <span class="comment">// add() returns an int, so sum's type will be deduced as an int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p>
<h2 id="type-deduction-must-have-something-to-deduce-from">Type deduction must have something to deduce from</h2>
<p>Type deduction will not work for objects that either do not have initializers or have empty initializers. It also will not work when the initializer has type void (or any other incomplete type).</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">auto</span> a;           <span class="comment">// The compiler is unable to deduce the type of a</span></span><br><span class="line">    <span class="keyword">auto</span> b { };       <span class="comment">// The compiler is unable to deduce the type of b</span></span><br><span class="line">    <span class="keyword">auto</span> c { <span class="built_in">foo</span>() }; <span class="comment">// Invalid: c can't have type incomplete type void</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="type-deduction-drops-const-from-the-deduced-type">Type deduction drops const from the deduced type</h2>
<p>In most cases, type deduction will drop the const from deduced types. For example: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> a { <span class="number">5</span> }; <span class="comment">// a has type const int</span></span><br><span class="line">    <span class="keyword">auto</span> b { a };      <span class="comment">// b has type int (const dropped)</span></span><br><span class="line">    <span class="comment">//const auto b { a }; // b has type const int (const dropped but reapplied)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure> ## Type deduction for string literals</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> s { <span class="string">"Hello, world"</span> }; <span class="comment">// s will be type const char*, not std::string</span></span><br></pre></td></tr></table></figure>
<p>If you want the type deduced from a string literal to be std::string or std::string_view, you’ll need to use the s or sv literal suffixes. <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string_view&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std::literals; <span class="comment">// easiest way to access the s and sv suffixes</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> s1 { <span class="string">"goo"</span>s };  <span class="comment">// "goo"s is a std::string literal, so s1 will be deduced as a std::string</span></span><br><span class="line">    <span class="keyword">auto</span> s2 { <span class="string">"moo"</span>sv }; <span class="comment">// "moo"sv is a std::string_view literal, so s2 will be deduced as a std::string_view</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></p>
<h2 id="type-deduction-and-constexpr">Type deduction and constexpr</h2>
<p>Because constexpr is not part of the type system, it cannot be deduced as part of type deduction. However, a constexpr variable is implicitly const, and this const will be dropped during type deduction (and can be readded if desired):</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">double</span> a { <span class="number">3.4</span> };  <span class="comment">// a has type const double (constexpr not part of type, const is implicit)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> b { a };                <span class="comment">// b has type double (const dropped)</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> c { a };          <span class="comment">// c has type const double (const dropped but reapplied)</span></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> d { a };      <span class="comment">// d has type const double (const dropped but implicitly reapplied by constexpr)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h1 id="type-deduction-for-functions">Type deduction for functions</h1>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>When using an auto return type, all return statements within the function must return values of the same type, otherwise an error will result.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">someFcn</span><span class="params">(<span class="type">bool</span> b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (b)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">5</span>; <span class="comment">// return type int</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">6.7</span>; <span class="comment">// return type double</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>Functions that use an auto return type must be fully defined before they can be used (a forward declaration is not sufficient). For example:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">foo</span>() &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// the compiler has only seen a forward declaration at this point</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//use of ‘auto foo()’ before deduction of ‘auto’</span></span><br></pre></td></tr></table></figure>
<pre><code>    Favor explicit return types over function return type deduction for normal functions.</code></pre>
<h2 id="trailing-return-type-syntax">Trailing return type syntax</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> -&gt; <span class="type">int</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="keyword">return</span> (x + y);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>In this case, auto does not perform type deduction -- it is just part of the syntax to use a trailing return type.</p>
<h2 id="type-deduction-cant-be-used-for-function-parameter-types">Type deduction can’t be used for function parameter types</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addAndPrint</span><span class="params">(<span class="keyword">auto</span> x, <span class="keyword">auto</span> y)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    std::cout &lt;&lt; x + y &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">addAndPrint</span>(<span class="number">2</span>, <span class="number">3</span>); <span class="comment">// case 1: call addAndPrint with int parameters</span></span><br><span class="line">    <span class="built_in">addAndPrint</span>(<span class="number">4.5</span>, <span class="number">6.7</span>); <span class="comment">// case 2: call addAndPrint with double parameters</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>Unfortunately, type deduction doesn’t work for function parameters, and prior to C++20, the above program won’t compile.</p>
<p>In C++20, the auto keyword was extended so that the above program will compile and function correctly -- however, auto is not invoking type deduction in this case. Rather, it is triggering a different feature called function templates that was designed to actually handle such cases.</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/11/18/Programming-Cpp-Chapter11-Function-Overloading-and-Function-Templates/" rel="prev" title="Chapter11-Function-Overloading-and-Function-Templates">
      <i class="fa fa-chevron-left"></i> Chapter11-Function-Overloading-and-Function-Templates
    </a></div>
      <div class="post-nav-item">
    <a href="/2024/12/01/Programming-Cpp-Chapter-12-compound-types-references-pointers/" rel="next" title="Chapter-12-compound-types-references-pointers">
      Chapter-12-compound-types-references-pointers <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#implicit-type-conversion"><span class="nav-number">1.</span> <span class="nav-text">Implicit type conversion</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#the-standard-conversions"><span class="nav-number">1.1.</span> <span class="nav-text">The standard conversions</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#numeric-promotion"><span class="nav-number">1.2.</span> <span class="nav-text">Numeric promotion</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#numeric-conversions"><span class="nav-number">2.</span> <span class="nav-text">Numeric conversions</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#safe-and-unsafe-conversions"><span class="nav-number">2.1.</span> <span class="nav-text">Safe and unsafe conversions</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#narrowing-conversions-list-initialization-and-constexpr-initializers"><span class="nav-number">3.</span> <span class="nav-text">Narrowing conversions, list initialization, and constexpr initializers</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#narrowing-coversions"><span class="nav-number">3.1.</span> <span class="nav-text">Narrowing coversions</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#make-intentional-narrowing-conversions-explicit"><span class="nav-number">3.2.</span> <span class="nav-text">Make intentional narrowing conversions explicit</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#brace-initialization-disallows-narrowing-conversions"><span class="nav-number">3.3.</span> <span class="nav-text">Brace initialization disallows narrowing conversions</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#some-constexpr-conversions-arent-considered-narrowing"><span class="nav-number">3.4.</span> <span class="nav-text">Some constexpr conversions aren’t considered narrowing</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#arithmetic-conversions"><span class="nav-number">4.</span> <span class="nav-text">Arithmetic conversions</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#typedefs-and-type-aliases"><span class="nav-number">5.</span> <span class="nav-text">Typedefs and type aliases</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#naming-type-aliases"><span class="nav-number">5.1.</span> <span class="nav-text">Naming type aliases</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#type-aliases-are-not-distinct-types"><span class="nav-number">5.2.</span> <span class="nav-text">Type aliases are not distinct types</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#the-scope-of-a-type-alias"><span class="nav-number">5.3.</span> <span class="nav-text">The scope of a type alias</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#typedefs"><span class="nav-number">5.4.</span> <span class="nav-text">Typedefs</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#when-should-we-use-type-aliases"><span class="nav-number">5.5.</span> <span class="nav-text">When should we use type aliases</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#using-type-aliases-for-platform-independent-coding"><span class="nav-number">5.5.1.</span> <span class="nav-text">Using type aliases for platform independent coding</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#using-type-aliases-to-make-complex-types-easier-to-read"><span class="nav-number">5.5.2.</span> <span class="nav-text">Using type aliases to make complex types easier to read</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#using-type-aliases-to-document-the-meaning-of-a-value"><span class="nav-number">5.5.3.</span> <span class="nav-text">Using type aliases to document the meaning of a value</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#using-type-aliases-for-easier-code-maintenance"><span class="nav-number">5.5.4.</span> <span class="nav-text">Using type aliases for easier code maintenance</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#type-deduction-for-objects-using-the-auto-keyword"><span class="nav-number">6.</span> <span class="nav-text">Type deduction for objects using the auto keyword</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#type-deduction-for-initialized-variables"><span class="nav-number">6.1.</span> <span class="nav-text">Type deduction for initialized variables</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#type-deduction-must-have-something-to-deduce-from"><span class="nav-number">6.2.</span> <span class="nav-text">Type deduction must have something to deduce from</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#type-deduction-drops-const-from-the-deduced-type"><span class="nav-number">6.3.</span> <span class="nav-text">Type deduction drops const from the deduced type</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#type-deduction-and-constexpr"><span class="nav-number">6.4.</span> <span class="nav-text">Type deduction and constexpr</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#type-deduction-for-functions"><span class="nav-number">7.</span> <span class="nav-text">Type deduction for functions</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#trailing-return-type-syntax"><span class="nav-number">7.1.</span> <span class="nav-text">Trailing return type syntax</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#type-deduction-cant-be-used-for-function-parameter-types"><span class="nav-number">7.2.</span> <span class="nav-text">Type deduction can’t be used for function parameter types</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Houxiong"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Houxiong</p>
  <div class="site-description" itemprop="description">To learn, To copy</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">31</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2024-11 – 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Houxiong</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/three-waves.min.js"></script>


  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>


